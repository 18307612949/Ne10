<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Project Ne10: /home/philwong/Ne10-gerrit/modules/dsp/NE10_fft_generic_float32.neonintrinsic.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="ne10_logo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Project Ne10
   
   </div>
   <div id="projectbrief">An Open Optimized Software Library Project for the ARM Architecture</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/philwong/Ne10-gerrit/modules/dsp/NE10_fft_generic_float32.neonintrinsic.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> *  Copyright 2014 ARM Limited</span>
<a name="l00003"></a>00003 <span class="comment"> *  All rights reserved.</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> *  Redistribution and use in source and binary forms, with or without</span>
<a name="l00006"></a>00006 <span class="comment"> *  modification, are permitted provided that the following conditions are met:</span>
<a name="l00007"></a>00007 <span class="comment"> *    * Redistributions of source code must retain the above copyright</span>
<a name="l00008"></a>00008 <span class="comment"> *      notice, this list of conditions and the following disclaimer.</span>
<a name="l00009"></a>00009 <span class="comment"> *    * Redistributions in binary form must reproduce the above copyright</span>
<a name="l00010"></a>00010 <span class="comment"> *      notice, this list of conditions and the following disclaimer in the</span>
<a name="l00011"></a>00011 <span class="comment"> *      documentation and/or other materials provided with the distribution.</span>
<a name="l00012"></a>00012 <span class="comment"> *    * Neither the name of ARM Limited nor the</span>
<a name="l00013"></a>00013 <span class="comment"> *      names of its contributors may be used to endorse or promote products</span>
<a name="l00014"></a>00014 <span class="comment"> *      derived from this software without specific prior written permission.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> *  THIS SOFTWARE IS PROVIDED BY ARM LIMITED AND CONTRIBUTORS &quot;AS IS&quot; AND</span>
<a name="l00017"></a>00017 <span class="comment"> *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a name="l00018"></a>00018 <span class="comment"> *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<a name="l00019"></a>00019 <span class="comment"> *  DISCLAIMED. IN NO EVENT SHALL ARM LIMITED BE LIABLE FOR ANY</span>
<a name="l00020"></a>00020 <span class="comment"> *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<a name="l00021"></a>00021 <span class="comment"> *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<a name="l00022"></a>00022 <span class="comment"> *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<a name="l00023"></a>00023 <span class="comment"> *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00024"></a>00024 <span class="comment"> *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00025"></a>00025 <span class="comment"> *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">/* license of Kiss FFT */</span>
<a name="l00029"></a>00029 <span class="comment">/*</span>
<a name="l00030"></a>00030 <span class="comment">Copyright (c) 2003-2010, Mark Borgerding</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">All rights reserved.</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00037"></a>00037 <span class="comment">    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00038"></a>00038 <span class="comment">    * Neither the author nor the names of any contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00039"></a>00039 <span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00041"></a>00041 <span class="comment">*/</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment">/*</span>
<a name="l00044"></a>00044 <span class="comment"> * NE10 Library : dsp/NE10_fft_generic_float32.neonintrisic.cpp</span>
<a name="l00045"></a>00045 <span class="comment"> *</span>
<a name="l00046"></a>00046 <span class="comment"> * This file must be compiled by C++ toolchain because some functions are</span>
<a name="l00047"></a>00047 <span class="comment"> * written as template functions to make it easier for compiler to</span>
<a name="l00048"></a>00048 <span class="comment"> * reduce branch jump.</span>
<a name="l00049"></a>00049 <span class="comment"> */</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#include &quot;NE10_types.h&quot;</span>
<a name="l00052"></a>00052 <span class="preprocessor">#include &quot;NE10_macros.h&quot;</span>
<a name="l00053"></a>00053 <span class="preprocessor">#include &quot;NE10_fft.neonintrinsic.h&quot;</span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &quot;NE10_fft_generic_float32.h&quot;</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">typedef</span> float32x4x2_t CPLX;
<a name="l00057"></a>00057 <span class="keyword">typedef</span> float32x4_t   REAL;
<a name="l00058"></a>00058 <span class="preprocessor">#define NE10_REAL_DUP_NEON_F32 vdupq_n_f32</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#define NE10_CPLX_LOAD(PTR) vld2q_f32 ((ne10_float32_t*) (PTR))</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define NE10_CPLX_STORE(PTR,OUT) \</span>
<a name="l00061"></a>00061 <span class="preprocessor">    do { \</span>
<a name="l00062"></a>00062 <span class="preprocessor">        vst2q_f32 ((ne10_float32_t*) (PTR), OUT); \</span>
<a name="l00063"></a>00063 <span class="preprocessor">    } while (0)</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>
<a name="l00065"></a>00065 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_LOAD_TW_AND_MUL (CPLX &amp;scratch_in,
<a name="l00066"></a>00066         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *ptr_in)
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068     CPLX scratch_tw;
<a name="l00069"></a>00069     float32x2_t d2_tmp = vld1_f32 ((ne10_float32_t *)ptr_in);
<a name="l00070"></a>00070     scratch_tw.val[0] = NE10_REAL_DUP_NEON_F32 (d2_tmp[0]);
<a name="l00071"></a>00071     scratch_tw.val[1] = NE10_REAL_DUP_NEON_F32 (d2_tmp[1]);
<a name="l00072"></a>00072     NE10_CPX_MUL_NEON_F32 (scratch_in, scratch_in, scratch_tw);
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="keyword">static</span> <span class="keyword">inline</span> REAL NE10_S_MUL_NEON_F32 (<span class="keyword">const</span> REAL vec,
<a name="l00076"></a>00076         <span class="keyword">const</span> ne10_float32_t scalar)
<a name="l00077"></a>00077 {
<a name="l00078"></a>00078     REAL scalar_neon = NE10_REAL_DUP_NEON_F32 (scalar);
<a name="l00079"></a>00079     REAL result = scalar_neon * vec;
<a name="l00080"></a>00080     <span class="keywordflow">return</span> result;
<a name="l00081"></a>00081 }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keyword">static</span> <span class="keyword">inline</span> REAL NE10_S_MLA_NEON_F32 (<span class="keyword">const</span> REAL dst,
<a name="l00084"></a>00084         <span class="keyword">const</span> REAL src,
<a name="l00085"></a>00085         <span class="keyword">const</span> ne10_float32_t scalar)
<a name="l00086"></a>00086 {
<a name="l00087"></a>00087     REAL scalar_neon = NE10_REAL_DUP_NEON_F32 (scalar);
<a name="l00088"></a>00088     <span class="keywordflow">return</span> vmlaq_f32 (dst, src, scalar_neon);
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">static</span> <span class="keyword">inline</span> REAL NE10_S_MLS_NEON_F32 (<span class="keyword">const</span> REAL dst,
<a name="l00092"></a>00092         <span class="keyword">const</span> REAL src,
<a name="l00093"></a>00093         <span class="keyword">const</span> ne10_float32_t scalar)
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095     REAL scalar_neon = NE10_REAL_DUP_NEON_F32 (scalar);
<a name="l00096"></a>00096     <span class="keywordflow">return</span> vmlsq_f32 (dst, src, scalar_neon);
<a name="l00097"></a>00097 }
<a name="l00098"></a>00098 
<a name="l00100"></a>00100 <span class="comment">// Multiply input with twiddles</span>
<a name="l00102"></a>00102 <span class="comment"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT2_MUL_TW_NEON (CPLX scratch_out[2],
<a name="l00103"></a>00103         <span class="keyword">const</span> CPLX scratch_in[2],
<a name="l00104"></a>00104         <span class="keyword">const</span> CPLX scratch_tw[1])
<a name="l00105"></a>00105 {
<a name="l00106"></a>00106     scratch_out[0] = scratch_in[0];
<a name="l00107"></a>00107     NE10_CPX_MUL_NEON_F32 (scratch_out[1], scratch_in[1], scratch_tw[0]);
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT3_MUL_TW_NEON (CPLX scratch_out[3],
<a name="l00111"></a>00111         <span class="keyword">const</span> CPLX scratch_in[3],
<a name="l00112"></a>00112         <span class="keyword">const</span> CPLX scratch_tw[2])
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114     NE10_FFT2_MUL_TW_NEON (scratch_out, scratch_in, scratch_tw);
<a name="l00115"></a>00115     NE10_CPX_MUL_NEON_F32 (scratch_out[2], scratch_in[2], scratch_tw[1]);
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT4_MUL_TW_NEON (CPLX scratch_out[4],
<a name="l00119"></a>00119         <span class="keyword">const</span> CPLX scratch_in[4],
<a name="l00120"></a>00120         <span class="keyword">const</span> CPLX scratch_tw[3])
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122     NE10_FFT3_MUL_TW_NEON (scratch_out, scratch_in, scratch_tw);
<a name="l00123"></a>00123     NE10_CPX_MUL_NEON_F32 (scratch_out[3], scratch_in[3], scratch_tw[2]);
<a name="l00124"></a>00124 }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT5_MUL_TW_NEON (CPLX scratch_out[5],
<a name="l00127"></a>00127         <span class="keyword">const</span> CPLX scratch_in[5],
<a name="l00128"></a>00128         <span class="keyword">const</span> CPLX scratch_tw[4])
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130     NE10_FFT4_MUL_TW_NEON (scratch_out, scratch_in, scratch_tw);
<a name="l00131"></a>00131     NE10_CPX_MUL_NEON_F32 (scratch_out[4], scratch_in[4], scratch_tw[3]);
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00135"></a>00135 <span class="comment">// Conj inplace.</span>
<a name="l00137"></a>00137 <span class="comment"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT2_CONJ (CPLX scratch_out[2])
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139     scratch_out[0].val[1] = -scratch_out[0].val[1];
<a name="l00140"></a>00140     scratch_out[1].val[1] = -scratch_out[1].val[1];
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT3_CONJ (CPLX scratch_out[3])
<a name="l00144"></a>00144 {
<a name="l00145"></a>00145     NE10_FFT2_CONJ (scratch_out);
<a name="l00146"></a>00146     scratch_out[2].val[1] = -scratch_out[2].val[1];
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT4_CONJ (CPLX scratch_out[4])
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151     NE10_FFT3_CONJ (scratch_out);
<a name="l00152"></a>00152     scratch_out[3].val[1] = -scratch_out[3].val[1];
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT5_CONJ (CPLX scratch_out[5])
<a name="l00156"></a>00156 {
<a name="l00157"></a>00157     NE10_FFT4_CONJ (scratch_out);
<a name="l00158"></a>00158     scratch_out[4].val[1] = -scratch_out[4].val[1];
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT8_CONJ (CPLX scratch_out[8])
<a name="l00162"></a>00162 {
<a name="l00163"></a>00163     NE10_FFT5_CONJ (scratch_out);
<a name="l00164"></a>00164     scratch_out[5].val[1] = -scratch_out[5].val[1];
<a name="l00165"></a>00165     scratch_out[6].val[1] = -scratch_out[6].val[1];
<a name="l00166"></a>00166     scratch_out[7].val[1] = -scratch_out[7].val[1];
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00170"></a>00170 <span class="comment">// Scaling</span>
<a name="l00171"></a>00171 <span class="comment">// If Macro NE10_DSP_CFFT_SCALING is not defined, these functions do nothing.</span>
<a name="l00173"></a>00173 <span class="comment"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT2_SCALING (CPLX scratch_out[2],
<a name="l00174"></a>00174         <span class="keyword">const</span> REAL one_by_fft_neon)
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176 <span class="preprocessor">#ifdef NE10_DSP_CFFT_SCALING</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>    scratch_out[0].val[0] *= one_by_fft_neon;
<a name="l00178"></a>00178     scratch_out[0].val[1] *= one_by_fft_neon;
<a name="l00179"></a>00179     scratch_out[1].val[0] *= one_by_fft_neon;
<a name="l00180"></a>00180     scratch_out[1].val[1] *= one_by_fft_neon;
<a name="l00181"></a>00181 <span class="preprocessor">#endif</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>}
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT3_SCALING (CPLX scratch_out[3],
<a name="l00185"></a>00185         <span class="keyword">const</span> REAL one_by_fft_neon)
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187 <span class="preprocessor">#ifdef NE10_DSP_CFFT_SCALING</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span>    NE10_FFT2_SCALING (scratch_out, one_by_fft_neon);
<a name="l00189"></a>00189     scratch_out[2].val[0] *= one_by_fft_neon;
<a name="l00190"></a>00190     scratch_out[2].val[1] *= one_by_fft_neon;
<a name="l00191"></a>00191 <span class="preprocessor">#endif</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>}
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT4_SCALING (CPLX scratch_out[4],
<a name="l00195"></a>00195         <span class="keyword">const</span> REAL one_by_fft_neon)
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197 <span class="preprocessor">#ifdef NE10_DSP_CFFT_SCALING</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span>    NE10_FFT3_SCALING (scratch_out, one_by_fft_neon);
<a name="l00199"></a>00199     scratch_out[3].val[0] *= one_by_fft_neon;
<a name="l00200"></a>00200     scratch_out[3].val[1] *= one_by_fft_neon;
<a name="l00201"></a>00201 <span class="preprocessor">#endif</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>}
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT5_SCALING (CPLX scratch_out[5],
<a name="l00205"></a>00205         <span class="keyword">const</span> REAL one_by_fft_neon)
<a name="l00206"></a>00206 {
<a name="l00207"></a>00207 <span class="preprocessor">#ifdef NE10_DSP_CFFT_SCALING</span>
<a name="l00208"></a>00208 <span class="preprocessor"></span>    NE10_FFT4_SCALING (scratch_out, one_by_fft_neon);
<a name="l00209"></a>00209     scratch_out[4].val[0] *= one_by_fft_neon;
<a name="l00210"></a>00210     scratch_out[4].val[1] *= one_by_fft_neon;
<a name="l00211"></a>00211 <span class="preprocessor">#endif</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span>}
<a name="l00213"></a>00213 
<a name="l00214"></a>00214 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT8_SCALING (CPLX scratch_out[8],
<a name="l00215"></a>00215         <span class="keyword">const</span> REAL one_by_fft_neon)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217 <span class="preprocessor">#ifdef NE10_DSP_CFFT_SCALING</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>    NE10_FFT5_SCALING (scratch_out, one_by_fft_neon);
<a name="l00219"></a>00219     scratch_out[5].val[0] *= one_by_fft_neon;
<a name="l00220"></a>00220     scratch_out[5].val[1] *= one_by_fft_neon;
<a name="l00221"></a>00221     scratch_out[6].val[0] *= one_by_fft_neon;
<a name="l00222"></a>00222     scratch_out[6].val[1] *= one_by_fft_neon;
<a name="l00223"></a>00223     scratch_out[7].val[0] *= one_by_fft_neon;
<a name="l00224"></a>00224     scratch_out[7].val[1] *= one_by_fft_neon;
<a name="l00225"></a>00225 <span class="preprocessor">#endif</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>}
<a name="l00227"></a>00227 
<a name="l00229"></a>00229 <span class="comment">// FFT Kernel</span>
<a name="l00230"></a>00230 <span class="comment">// F: Forward</span>
<a name="l00231"></a>00231 <span class="comment">// C: Complex</span>
<a name="l00232"></a>00232 <span class="comment">// U: Unscaled</span>
<a name="l00234"></a>00234 <span class="comment"></span><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT2_FUC_NEON_F32 (CPLX scratch_out[2],
<a name="l00235"></a>00235         <span class="keyword">const</span> CPLX scratch_in[2])
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237     NE10_CPX_ADD_NEON_F32 (scratch_out[0], scratch_in[0], scratch_in[1]);
<a name="l00238"></a>00238     NE10_CPX_SUB_NEON_F32 (scratch_out[1], scratch_in[0], scratch_in[1]);
<a name="l00239"></a>00239 }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT3_FUC_NEON_F32 (CPLX Fout[3],
<a name="l00242"></a>00242         <span class="keyword">const</span> CPLX Fin[3])
<a name="l00243"></a>00243 {
<a name="l00244"></a>00244     <span class="keyword">const</span> float32x4_t TW_3IN_NEON_F32 = vdupq_n_f32 (TW_3IN_F32);
<a name="l00245"></a>00245     <span class="keyword">const</span> float32x4_t HALF_NEON_F32 = vdupq_n_f32 (0.5f);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     CPLX scratch[4];
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     Fout[0] = Fin[0];
<a name="l00250"></a>00250     Fout[1] = Fin[1];
<a name="l00251"></a>00251     Fout[2] = Fin[2];
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     scratch[1] = Fout[1];
<a name="l00254"></a>00254     scratch[2] = Fout[2];
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     NE10_CPX_ADD_NEON_F32 (scratch[3], scratch[1], scratch[2]);
<a name="l00257"></a>00257     NE10_CPX_SUB_NEON_F32 (scratch[0], scratch[1], scratch[2]);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259     Fout[1].val[0] = Fout[0].val[0] - scratch[3].val[0] * HALF_NEON_F32;
<a name="l00260"></a>00260     Fout[1].val[1] = Fout[0].val[1] - scratch[3].val[1] * HALF_NEON_F32;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     scratch[0].val[0] = scratch[0].val[0] * TW_3IN_NEON_F32;
<a name="l00263"></a>00263     scratch[0].val[1] = scratch[0].val[1] * TW_3IN_NEON_F32;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     Fout[0].val[0] += scratch[3].val[0];
<a name="l00266"></a>00266     Fout[0].val[1] += scratch[3].val[1];
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     Fout[2].val[0] = Fout[1].val[0] + scratch[0].val[1];
<a name="l00269"></a>00269     Fout[2].val[1] = Fout[1].val[1] - scratch[0].val[0];
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     Fout[1].val[0] -= scratch[0].val[1];
<a name="l00272"></a>00272     Fout[1].val[1] += scratch[0].val[0];
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT4_FUC_NEON_F32 (CPLX scratch_out[4],
<a name="l00276"></a>00276         <span class="keyword">const</span> CPLX scratch_in[4])
<a name="l00277"></a>00277 {
<a name="l00278"></a>00278     CPLX scratch[4];
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     NE10_CPX_ADD_NEON_F32 (scratch[0], scratch_in[0], scratch_in[2]);
<a name="l00281"></a>00281     NE10_CPX_SUB_NEON_F32 (scratch[1], scratch_in[0], scratch_in[2]);
<a name="l00282"></a>00282     NE10_CPX_ADD_NEON_F32 (scratch[2], scratch_in[1], scratch_in[3]);
<a name="l00283"></a>00283     NE10_CPX_SUB_NEON_F32 (scratch[3], scratch_in[1], scratch_in[3]);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     NE10_CPX_SUB_NEON_F32 (scratch_out[2], scratch[0], scratch[2]);
<a name="l00286"></a>00286     NE10_CPX_ADD_NEON_F32 (scratch_out[0], scratch[0], scratch[2]);
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     scratch_out[1].val[0] = scratch[1].val[0] + scratch[3].val[1];
<a name="l00289"></a>00289     scratch_out[1].val[1] = scratch[1].val[1] - scratch[3].val[0];
<a name="l00290"></a>00290     scratch_out[3].val[0] = scratch[1].val[0] - scratch[3].val[1];
<a name="l00291"></a>00291     scratch_out[3].val[1] = scratch[1].val[1] + scratch[3].val[0];
<a name="l00292"></a>00292 }
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT4_FUC_INPLACE_NEON_F32 (CPLX scratch_out[4])
<a name="l00295"></a>00295 {
<a name="l00296"></a>00296     CPLX scratch[4];
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     NE10_CPX_ADD_NEON_F32 (scratch[0], scratch_out[0], scratch_out[2]);
<a name="l00299"></a>00299     NE10_CPX_SUB_NEON_F32 (scratch[1], scratch_out[0], scratch_out[2]);
<a name="l00300"></a>00300     NE10_CPX_ADD_NEON_F32 (scratch[2], scratch_out[1], scratch_out[3]);
<a name="l00301"></a>00301     NE10_CPX_SUB_NEON_F32 (scratch[3], scratch_out[1], scratch_out[3]);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     NE10_CPX_SUB_NEON_F32 (scratch_out[2], scratch[0], scratch[2]);
<a name="l00304"></a>00304     NE10_CPX_ADD_NEON_F32 (scratch_out[0], scratch[0], scratch[2]);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     scratch_out[1].val[0] = scratch[1].val[0] + scratch[3].val[1];
<a name="l00307"></a>00307     scratch_out[1].val[1] = scratch[1].val[1] - scratch[3].val[0];
<a name="l00308"></a>00308     scratch_out[3].val[0] = scratch[1].val[0] - scratch[3].val[1];
<a name="l00309"></a>00309     scratch_out[3].val[1] = scratch[1].val[1] + scratch[3].val[0];
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT5_FUC_INPLACE_NEON_F32 (CPLX Fout[5])
<a name="l00313"></a>00313 {
<a name="l00314"></a>00314     CPLX s[6];
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     NE10_CPX_ADD_NEON_F32 (s[1], Fout[1], Fout[4]);
<a name="l00317"></a>00317     NE10_CPX_ADD_NEON_F32 (s[2], Fout[2], Fout[3]);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     s[0] = Fout[0];
<a name="l00320"></a>00320     s[5] = Fout[0];
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     Fout[0].val[0] = Fout[0].val[0] + s[1].val[0] + s[2].val[0];
<a name="l00323"></a>00323     Fout[0].val[1] = Fout[0].val[1] + s[1].val[1] + s[2].val[1];
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     s[0].val[0] = NE10_S_MLA_NEON_F32 (s[0].val[0], s[1].val[0], TW_5A_F32.r);
<a name="l00326"></a>00326     s[0].val[1] = NE10_S_MLA_NEON_F32 (s[0].val[1], s[1].val[1], TW_5A_F32.r);
<a name="l00327"></a>00327     s[5].val[0] = NE10_S_MLA_NEON_F32 (s[5].val[0], s[1].val[0], TW_5B_F32.r);
<a name="l00328"></a>00328     s[5].val[1] = NE10_S_MLA_NEON_F32 (s[5].val[1], s[1].val[1], TW_5B_F32.r);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     s[0].val[0] = NE10_S_MLA_NEON_F32 (s[0].val[0], s[2].val[0], TW_5B_F32.r);
<a name="l00331"></a>00331     s[0].val[1] = NE10_S_MLA_NEON_F32 (s[0].val[1], s[2].val[1], TW_5B_F32.r);
<a name="l00332"></a>00332     s[5].val[0] = NE10_S_MLA_NEON_F32 (s[5].val[0], s[2].val[0], TW_5A_F32.r);
<a name="l00333"></a>00333     s[5].val[1] = NE10_S_MLA_NEON_F32 (s[5].val[1], s[2].val[1], TW_5A_F32.r);
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     NE10_CPX_SUB_NEON_F32 (s[4], Fout[1], Fout[4]);
<a name="l00336"></a>00336     NE10_CPX_SUB_NEON_F32 (s[3], Fout[2], Fout[3]);
<a name="l00337"></a>00337 
<a name="l00338"></a>00338     s[1].val[0] = NE10_S_MUL_NEON_F32 (s[4].val[1], TW_5A_F32.i);
<a name="l00339"></a>00339     s[1].val[1] = -NE10_S_MUL_NEON_F32 (s[4].val[0], TW_5A_F32.i);
<a name="l00340"></a>00340     s[2].val[0] = -NE10_S_MUL_NEON_F32 (s[4].val[1], TW_5B_F32.i);
<a name="l00341"></a>00341     s[2].val[1] = NE10_S_MUL_NEON_F32 (s[4].val[0], TW_5B_F32.i);
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     s[1].val[0] = NE10_S_MLA_NEON_F32 (s[1].val[0], s[3].val[1], TW_5B_F32.i);
<a name="l00344"></a>00344     s[1].val[1] = NE10_S_MLS_NEON_F32 (s[1].val[1], s[3].val[0], TW_5B_F32.i);
<a name="l00345"></a>00345     s[2].val[0] = NE10_S_MLA_NEON_F32 (s[2].val[0], s[3].val[1], TW_5A_F32.i);
<a name="l00346"></a>00346     s[2].val[1] = NE10_S_MLS_NEON_F32 (s[2].val[1], s[3].val[0], TW_5A_F32.i);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     NE10_CPX_SUB_NEON_F32 (Fout[1], s[0], s[1]);
<a name="l00349"></a>00349     NE10_CPX_ADD_NEON_F32 (Fout[4], s[0], s[1]);
<a name="l00350"></a>00350     NE10_CPX_ADD_NEON_F32 (Fout[2], s[5], s[2]);
<a name="l00351"></a>00351     NE10_CPX_SUB_NEON_F32 (Fout[3], s[5], s[2]);
<a name="l00352"></a>00352 }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="preprocessor">#define NE10_BUTTERFLY_INDEX_NEON_F32(OUT,IN,OUT_I,OUT_J,IN_I,IN_J) \</span>
<a name="l00355"></a>00355 <span class="preprocessor">    do { \</span>
<a name="l00356"></a>00356 <span class="preprocessor">        NE10_CPX_ADD_NEON_F32 (OUT[OUT_I],IN[IN_I],IN[IN_J]); \</span>
<a name="l00357"></a>00357 <span class="preprocessor">        NE10_CPX_SUB_NEON_F32 (OUT[OUT_J],IN[IN_I],IN[IN_J]); \</span>
<a name="l00358"></a>00358 <span class="preprocessor">    } while (0)</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>
<a name="l00360"></a>00360 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> NE10_FFT8_FUC_NEON_F32 (CPLX out[8],
<a name="l00361"></a>00361         <span class="keyword">const</span> CPLX in[8])
<a name="l00362"></a>00362 {
<a name="l00363"></a>00363     PRINT_HIT;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     CPLX s[8];
<a name="l00366"></a>00366     <span class="keyword">const</span> <span class="keyword">static</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> TW_8[4] =
<a name="l00367"></a>00367     {
<a name="l00368"></a>00368         {  1.00000,  0.00000 },
<a name="l00369"></a>00369         {  0.70711, -0.70711 },
<a name="l00370"></a>00370         {  0.00000, -1.00000 },
<a name="l00371"></a>00371         { -0.70711, -0.70711 },
<a name="l00372"></a>00372     };
<a name="l00373"></a>00373 
<a name="l00374"></a>00374     <span class="comment">// STAGE - 1</span>
<a name="l00375"></a>00375     <span class="comment">// in -&gt; s</span>
<a name="l00376"></a>00376     {
<a name="l00377"></a>00377         NE10_BUTTERFLY_INDEX_NEON_F32 (s, in, 0, 4, 0, 4);
<a name="l00378"></a>00378         NE10_BUTTERFLY_INDEX_NEON_F32 (s, in, 1, 5, 1, 5);
<a name="l00379"></a>00379         NE10_BUTTERFLY_INDEX_NEON_F32 (s, in, 2, 6, 2, 6);
<a name="l00380"></a>00380         NE10_BUTTERFLY_INDEX_NEON_F32 (s, in, 3, 7, 3, 7);
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     <span class="comment">// STAGE - 2</span>
<a name="l00384"></a>00384     <span class="comment">// s -&gt; out</span>
<a name="l00385"></a>00385     {
<a name="l00386"></a>00386         <span class="comment">// TW</span>
<a name="l00387"></a>00387 <span class="preprocessor">#define NE10_CPX_MUL_TW8_NEON_F32(OUT,TW_8_TABLE,OUT_I,TW_J) \</span>
<a name="l00388"></a>00388 <span class="preprocessor">        do { \</span>
<a name="l00389"></a>00389 <span class="preprocessor">            ne10_fft_cpx_float32_t TW_TMP = TW_8_TABLE[TW_J]; \</span>
<a name="l00390"></a>00390 <span class="preprocessor">            CPLX TW_TMP_NEON; \</span>
<a name="l00391"></a>00391 <span class="preprocessor">            TW_TMP_NEON.val[0] = NE10_REAL_DUP_NEON_F32 (TW_TMP.r); \</span>
<a name="l00392"></a>00392 <span class="preprocessor">            TW_TMP_NEON.val[1] = NE10_REAL_DUP_NEON_F32 (TW_TMP.i); \</span>
<a name="l00393"></a>00393 <span class="preprocessor">            NE10_CPX_MUL_NEON_F32 (OUT[OUT_I],OUT[OUT_I],TW_TMP_NEON); \</span>
<a name="l00394"></a>00394 <span class="preprocessor">        } while (0)</span>
<a name="l00395"></a>00395 <span class="preprocessor"></span>
<a name="l00396"></a>00396         NE10_CPX_MUL_TW8_NEON_F32 (s, TW_8, 4, 0);
<a name="l00397"></a>00397         NE10_CPX_MUL_TW8_NEON_F32 (s, TW_8, 5, 1);
<a name="l00398"></a>00398         NE10_CPX_MUL_TW8_NEON_F32 (s, TW_8, 6, 2);
<a name="l00399"></a>00399         NE10_CPX_MUL_TW8_NEON_F32 (s, TW_8, 7, 3);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401         NE10_BUTTERFLY_INDEX_NEON_F32 (out, s, 0, 2, 0, 2);
<a name="l00402"></a>00402         NE10_BUTTERFLY_INDEX_NEON_F32 (out, s, 1, 3, 1, 3);
<a name="l00403"></a>00403         NE10_BUTTERFLY_INDEX_NEON_F32 (out, s, 4, 6, 4, 6);
<a name="l00404"></a>00404         NE10_BUTTERFLY_INDEX_NEON_F32 (out, s, 5, 7, 5, 7);
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406     <span class="comment">// STAGE - 3</span>
<a name="l00407"></a>00407     <span class="comment">// out -&gt; s</span>
<a name="l00408"></a>00408     {
<a name="l00409"></a>00409         <span class="comment">// TW</span>
<a name="l00410"></a>00410         NE10_CPX_MUL_TW8_NEON_F32 (out, TW_8, 2, 0);
<a name="l00411"></a>00411         NE10_CPX_MUL_TW8_NEON_F32 (out, TW_8, 3, 2);
<a name="l00412"></a>00412         NE10_CPX_MUL_TW8_NEON_F32 (out, TW_8, 6, 0);
<a name="l00413"></a>00413         NE10_CPX_MUL_TW8_NEON_F32 (out, TW_8, 7, 2);
<a name="l00414"></a>00414 <span class="preprocessor">#undef NE10_CPX_MUL_TW8_NEON_F32</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>
<a name="l00416"></a>00416         NE10_BUTTERFLY_INDEX_NEON_F32 (s, out, 0, 4, 0, 1);
<a name="l00417"></a>00417         NE10_BUTTERFLY_INDEX_NEON_F32 (s, out, 2, 6, 2, 3);
<a name="l00418"></a>00418         NE10_BUTTERFLY_INDEX_NEON_F32 (s, out, 1, 5, 4, 5);
<a name="l00419"></a>00419         NE10_BUTTERFLY_INDEX_NEON_F32 (s, out, 3, 7, 6, 7);
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 
<a name="l00422"></a>00422     out[0] = s[0];
<a name="l00423"></a>00423     out[1] = s[1];
<a name="l00424"></a>00424     out[2] = s[2];
<a name="l00425"></a>00425     out[3] = s[3];
<a name="l00426"></a>00426     out[4] = s[4];
<a name="l00427"></a>00427     out[5] = s[5];
<a name="l00428"></a>00428     out[6] = s[6];
<a name="l00429"></a>00429     out[7] = s[7];
<a name="l00430"></a>00430 }
<a name="l00431"></a>00431 
<a name="l00433"></a>00433 <span class="comment">// Following are butterfly functions</span>
<a name="l00435"></a>00435 <span class="comment"></span><span class="keyword">template</span>&lt;ne10_<span class="keywordtype">int</span>32_t is_first_stage, ne10_<span class="keywordtype">int</span>32_t is_inverse&gt;
<a name="l00436"></a>00436 <span class="keyword">static</span> <span class="keywordtype">void</span> ne10_radix_2_butterfly_float32_neon (CPLX *Fout,
<a name="l00437"></a>00437         <span class="keyword">const</span> CPLX *Fin,
<a name="l00438"></a>00438         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l00439"></a>00439         <span class="keyword">const</span> ne10_int32_t fstride,
<a name="l00440"></a>00440         <span class="keyword">const</span> ne10_int32_t out_step,
<a name="l00441"></a>00441         <span class="keyword">const</span> ne10_int32_t nfft)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443     PRINT_HIT;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     CPLX in[2];
<a name="l00446"></a>00446     CPLX out[2];
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="keyword">const</span> ne10_int32_t in_step = nfft / 2;
<a name="l00449"></a>00449     ne10_int32_t f_count;
<a name="l00450"></a>00450     ne10_int32_t m_count;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452     <span class="keyword">const</span> REAL one_by_fft_neon = NE10_REAL_DUP_NEON_F32 (0.25 / nfft);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     <span class="keywordflow">for</span> (f_count = fstride; f_count &gt; 0; f_count--)
<a name="l00455"></a>00455     {
<a name="l00456"></a>00456         <span class="keywordflow">for</span> (m_count = out_step; m_count &gt; 0; m_count--)
<a name="l00457"></a>00457         {
<a name="l00458"></a>00458             in[0] = NE10_CPLX_LOAD (Fin + 0 * in_step);
<a name="l00459"></a>00459             in[1] = NE10_CPLX_LOAD (Fin + 1 * in_step);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00462"></a>00462             {
<a name="l00463"></a>00463                 NE10_FFT2_CONJ (in);
<a name="l00464"></a>00464             }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00467"></a>00467             {
<a name="l00468"></a>00468                 NE10_LOAD_TW_AND_MUL (in[1], twiddles);
<a name="l00469"></a>00469             }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471             NE10_FFT2_FUC_NEON_F32 (out, in);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00474"></a>00474             {
<a name="l00475"></a>00475                 NE10_FFT2_CONJ (out);
<a name="l00476"></a>00476 
<a name="l00477"></a>00477                 <span class="keywordflow">if</span> (is_first_stage == 1)
<a name="l00478"></a>00478                 {
<a name="l00479"></a>00479                     NE10_FFT2_SCALING (out, one_by_fft_neon);
<a name="l00480"></a>00480                 }
<a name="l00481"></a>00481             }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483             NE10_CPLX_STORE (Fout + 0 * out_step, out[0]);
<a name="l00484"></a>00484             NE10_CPLX_STORE (Fout + 1 * out_step, out[1]);
<a name="l00485"></a>00485 
<a name="l00486"></a>00486             Fin++;
<a name="l00487"></a>00487 
<a name="l00488"></a>00488             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00489"></a>00489             {
<a name="l00490"></a>00490                 Fout++;
<a name="l00491"></a>00491                 twiddles++;
<a name="l00492"></a>00492             }
<a name="l00493"></a>00493             <span class="keywordflow">else</span>
<a name="l00494"></a>00494             {
<a name="l00495"></a>00495                 Fout += 2;
<a name="l00496"></a>00496             }
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498         <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00499"></a>00499         {
<a name="l00500"></a>00500             twiddles -= out_step;
<a name="l00501"></a>00501             Fout += (2 - 1) * out_step;
<a name="l00502"></a>00502         }
<a name="l00503"></a>00503     }
<a name="l00504"></a>00504 }
<a name="l00505"></a>00505 <span class="keyword">template</span>&lt;ne10_<span class="keywordtype">int</span>32_t is_first_stage, ne10_<span class="keywordtype">int</span>32_t is_inverse&gt;
<a name="l00506"></a>00506 <span class="keyword">static</span> <span class="keywordtype">void</span> ne10_radix_4_butterfly_float32_neon (CPLX *Fout,
<a name="l00507"></a>00507         <span class="keyword">const</span> CPLX *Fin,
<a name="l00508"></a>00508         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l00509"></a>00509         <span class="keyword">const</span> ne10_int32_t fstride,
<a name="l00510"></a>00510         <span class="keyword">const</span> ne10_int32_t out_step,
<a name="l00511"></a>00511         <span class="keyword">const</span> ne10_int32_t nfft)
<a name="l00512"></a>00512 {
<a name="l00513"></a>00513     CPLX in[4];
<a name="l00514"></a>00514 
<a name="l00515"></a>00515     <span class="keyword">const</span> ne10_int32_t in_step = nfft / 4;
<a name="l00516"></a>00516     ne10_int32_t f_count;
<a name="l00517"></a>00517     ne10_int32_t m_count;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     <span class="keyword">const</span> REAL one_by_fft_neon = NE10_REAL_DUP_NEON_F32 (0.25 / nfft);
<a name="l00520"></a>00520 
<a name="l00521"></a>00521     <span class="keywordflow">for</span> (f_count = fstride; f_count &gt; 0; f_count--)
<a name="l00522"></a>00522     {
<a name="l00523"></a>00523         <span class="keywordflow">for</span> (m_count = out_step; m_count &gt; 0; m_count--)
<a name="l00524"></a>00524         {
<a name="l00525"></a>00525             in[0] = NE10_CPLX_LOAD (Fin + 0 * in_step);
<a name="l00526"></a>00526             in[1] = NE10_CPLX_LOAD (Fin + 1 * in_step);
<a name="l00527"></a>00527             in[2] = NE10_CPLX_LOAD (Fin + 2 * in_step);
<a name="l00528"></a>00528             in[3] = NE10_CPLX_LOAD (Fin + 3 * in_step);
<a name="l00529"></a>00529 
<a name="l00530"></a>00530             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00531"></a>00531             {
<a name="l00532"></a>00532                 NE10_FFT4_CONJ (in);
<a name="l00533"></a>00533             }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00536"></a>00536             {
<a name="l00537"></a>00537                 NE10_LOAD_TW_AND_MUL (in[1], twiddles);
<a name="l00538"></a>00538                 NE10_LOAD_TW_AND_MUL (in[2], twiddles + out_step);
<a name="l00539"></a>00539                 NE10_LOAD_TW_AND_MUL (in[3], twiddles + out_step * 2);
<a name="l00540"></a>00540             }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542             NE10_FFT4_FUC_INPLACE_NEON_F32 (in);
<a name="l00543"></a>00543 
<a name="l00544"></a>00544             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00545"></a>00545             {
<a name="l00546"></a>00546                 NE10_FFT4_CONJ (in);
<a name="l00547"></a>00547                 <span class="keywordflow">if</span> (is_first_stage == 1)
<a name="l00548"></a>00548                 {
<a name="l00549"></a>00549                     NE10_FFT4_SCALING (in, one_by_fft_neon);
<a name="l00550"></a>00550                 }
<a name="l00551"></a>00551             }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553             NE10_CPLX_STORE (Fout + 0 * out_step, in[0]);
<a name="l00554"></a>00554             NE10_CPLX_STORE (Fout + 1 * out_step, in[1]);
<a name="l00555"></a>00555             NE10_CPLX_STORE (Fout + 2 * out_step, in[2]);
<a name="l00556"></a>00556             NE10_CPLX_STORE (Fout + 3 * out_step, in[3]);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558             Fin++;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00561"></a>00561             {
<a name="l00562"></a>00562                 Fout++;
<a name="l00563"></a>00563                 twiddles++;
<a name="l00564"></a>00564             }
<a name="l00565"></a>00565             <span class="keywordflow">else</span>
<a name="l00566"></a>00566             {
<a name="l00567"></a>00567                 Fout += 4;
<a name="l00568"></a>00568             }
<a name="l00569"></a>00569         }
<a name="l00570"></a>00570         <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00571"></a>00571         {
<a name="l00572"></a>00572             twiddles -= out_step;
<a name="l00573"></a>00573             Fout += (4 - 1) * out_step;
<a name="l00574"></a>00574         }
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="keyword">template</span>&lt;ne10_<span class="keywordtype">int</span>32_t is_first_stage, ne10_<span class="keywordtype">int</span>32_t is_inverse&gt;
<a name="l00579"></a>00579 <span class="keyword">static</span> <span class="keywordtype">void</span> ne10_radix_3_butterfly_float32_neon (CPLX *Fout,
<a name="l00580"></a>00580         <span class="keyword">const</span> CPLX *Fin,
<a name="l00581"></a>00581         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l00582"></a>00582         <span class="keyword">const</span> ne10_int32_t fstride,
<a name="l00583"></a>00583         <span class="keyword">const</span> ne10_int32_t out_step,
<a name="l00584"></a>00584         <span class="keyword">const</span> ne10_int32_t nfft)
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586     CPLX in[3];
<a name="l00587"></a>00587     CPLX out[3];
<a name="l00588"></a>00588 
<a name="l00589"></a>00589     <span class="keyword">const</span> ne10_int32_t in_step = nfft / 3;
<a name="l00590"></a>00590     ne10_int32_t f_count;
<a name="l00591"></a>00591     ne10_int32_t m_count;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     <span class="keyword">const</span> REAL one_by_fft_neon = NE10_REAL_DUP_NEON_F32 (0.25 / nfft);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595     <span class="keywordflow">for</span> (f_count = fstride; f_count &gt; 0; f_count--)
<a name="l00596"></a>00596     {
<a name="l00597"></a>00597         <span class="keywordflow">for</span> (m_count = out_step; m_count &gt; 0; m_count--)
<a name="l00598"></a>00598         {
<a name="l00599"></a>00599             in[0] = NE10_CPLX_LOAD (Fin + 0 * in_step);
<a name="l00600"></a>00600             in[1] = NE10_CPLX_LOAD (Fin + 1 * in_step);
<a name="l00601"></a>00601             in[2] = NE10_CPLX_LOAD (Fin + 2 * in_step);
<a name="l00602"></a>00602 
<a name="l00603"></a>00603             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00604"></a>00604             {
<a name="l00605"></a>00605                 NE10_FFT3_CONJ (in);
<a name="l00606"></a>00606             }
<a name="l00607"></a>00607 
<a name="l00608"></a>00608             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00609"></a>00609             {
<a name="l00610"></a>00610                 NE10_LOAD_TW_AND_MUL (in[1], twiddles);
<a name="l00611"></a>00611                 NE10_LOAD_TW_AND_MUL (in[2], twiddles + out_step);
<a name="l00612"></a>00612             }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614             NE10_FFT3_FUC_NEON_F32 (out, in);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00617"></a>00617             {
<a name="l00618"></a>00618                 NE10_FFT3_CONJ (out);
<a name="l00619"></a>00619                 <span class="keywordflow">if</span> (is_first_stage == 1)
<a name="l00620"></a>00620                 {
<a name="l00621"></a>00621                     NE10_FFT3_SCALING (out, one_by_fft_neon);
<a name="l00622"></a>00622                 }
<a name="l00623"></a>00623             }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625             NE10_CPLX_STORE (Fout + 0 * out_step, out[0]);
<a name="l00626"></a>00626             NE10_CPLX_STORE (Fout + 1 * out_step, out[1]);
<a name="l00627"></a>00627             NE10_CPLX_STORE (Fout + 2 * out_step, out[2]);
<a name="l00628"></a>00628 
<a name="l00629"></a>00629             Fin++;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00632"></a>00632             {
<a name="l00633"></a>00633                 Fout++;
<a name="l00634"></a>00634                 twiddles++;
<a name="l00635"></a>00635             }
<a name="l00636"></a>00636             <span class="keywordflow">else</span>
<a name="l00637"></a>00637             {
<a name="l00638"></a>00638                 Fout += 3;
<a name="l00639"></a>00639             }
<a name="l00640"></a>00640         }
<a name="l00641"></a>00641         <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00642"></a>00642         {
<a name="l00643"></a>00643             twiddles -= out_step;
<a name="l00644"></a>00644             Fout += (3 - 1) * out_step;
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646     }
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="keyword">template</span>&lt;ne10_<span class="keywordtype">int</span>32_t is_first_stage, ne10_<span class="keywordtype">int</span>32_t is_inverse&gt;
<a name="l00650"></a>00650 <span class="keyword">static</span> <span class="keywordtype">void</span> ne10_radix_5_butterfly_float32_neon (CPLX *Fout,
<a name="l00651"></a>00651         <span class="keyword">const</span> CPLX *Fin,
<a name="l00652"></a>00652         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l00653"></a>00653         <span class="keyword">const</span> ne10_int32_t fstride,
<a name="l00654"></a>00654         <span class="keyword">const</span> ne10_int32_t out_step,
<a name="l00655"></a>00655         <span class="keyword">const</span> ne10_int32_t nfft)
<a name="l00656"></a>00656 {
<a name="l00657"></a>00657     CPLX in[5];
<a name="l00658"></a>00658 
<a name="l00659"></a>00659     <span class="keyword">const</span> ne10_int32_t in_step = nfft / 5;
<a name="l00660"></a>00660     ne10_int32_t f_count;
<a name="l00661"></a>00661     ne10_int32_t m_count;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="keyword">const</span> REAL one_by_fft_neon = NE10_REAL_DUP_NEON_F32 (0.25 / nfft);
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     <span class="keywordflow">for</span> (f_count = fstride; f_count &gt; 0; f_count--)
<a name="l00666"></a>00666     {
<a name="l00667"></a>00667         <span class="keywordflow">for</span> (m_count = out_step; m_count &gt; 0; m_count--)
<a name="l00668"></a>00668         {
<a name="l00669"></a>00669             in[0] = NE10_CPLX_LOAD (Fin + 0 * in_step);
<a name="l00670"></a>00670             in[1] = NE10_CPLX_LOAD (Fin + 1 * in_step);
<a name="l00671"></a>00671             in[2] = NE10_CPLX_LOAD (Fin + 2 * in_step);
<a name="l00672"></a>00672             in[3] = NE10_CPLX_LOAD (Fin + 3 * in_step);
<a name="l00673"></a>00673             in[4] = NE10_CPLX_LOAD (Fin + 4 * in_step);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00676"></a>00676             {
<a name="l00677"></a>00677                 NE10_FFT5_CONJ (in);
<a name="l00678"></a>00678             }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00681"></a>00681             {
<a name="l00682"></a>00682                 NE10_LOAD_TW_AND_MUL (in[1], twiddles);
<a name="l00683"></a>00683                 NE10_LOAD_TW_AND_MUL (in[2], twiddles + out_step);
<a name="l00684"></a>00684                 NE10_LOAD_TW_AND_MUL (in[3], twiddles + out_step * 2);
<a name="l00685"></a>00685                 NE10_LOAD_TW_AND_MUL (in[4], twiddles + out_step * 3);
<a name="l00686"></a>00686             }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688             NE10_FFT5_FUC_INPLACE_NEON_F32 (in);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00691"></a>00691             {
<a name="l00692"></a>00692                 NE10_FFT5_CONJ (in);
<a name="l00693"></a>00693                 <span class="keywordflow">if</span> (is_first_stage == 1)
<a name="l00694"></a>00694                 {
<a name="l00695"></a>00695                     NE10_FFT5_SCALING (in, one_by_fft_neon);
<a name="l00696"></a>00696                 }
<a name="l00697"></a>00697             }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699             NE10_CPLX_STORE (Fout + 0 * out_step, in[0]);
<a name="l00700"></a>00700             NE10_CPLX_STORE (Fout + 1 * out_step, in[1]);
<a name="l00701"></a>00701             NE10_CPLX_STORE (Fout + 2 * out_step, in[2]);
<a name="l00702"></a>00702             NE10_CPLX_STORE (Fout + 3 * out_step, in[3]);
<a name="l00703"></a>00703             NE10_CPLX_STORE (Fout + 4 * out_step, in[4]);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705             Fin++;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707             <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00708"></a>00708             {
<a name="l00709"></a>00709                 Fout++;
<a name="l00710"></a>00710                 twiddles++;
<a name="l00711"></a>00711             }
<a name="l00712"></a>00712             <span class="keywordflow">else</span>
<a name="l00713"></a>00713             {
<a name="l00714"></a>00714                 Fout += 5;
<a name="l00715"></a>00715             }
<a name="l00716"></a>00716         }
<a name="l00717"></a>00717         <span class="keywordflow">if</span> (is_first_stage == 0)
<a name="l00718"></a>00718         {
<a name="l00719"></a>00719             twiddles -= out_step;
<a name="l00720"></a>00720             Fout += (5 - 1) * out_step;
<a name="l00721"></a>00721         }
<a name="l00722"></a>00722     }
<a name="l00723"></a>00723 }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 <span class="keyword">template</span>&lt;ne10_<span class="keywordtype">int</span>32_t is_first_stage, ne10_<span class="keywordtype">int</span>32_t is_inverse&gt;
<a name="l00726"></a>00726 <span class="keyword">static</span> <span class="keywordtype">void</span> ne10_radix_8_butterfly_float32_neon (CPLX *Fout,
<a name="l00727"></a>00727         <span class="keyword">const</span> CPLX *Fin,
<a name="l00728"></a>00728         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l00729"></a>00729         <span class="keyword">const</span> ne10_int32_t fstride,
<a name="l00730"></a>00730         <span class="keyword">const</span> ne10_int32_t out_step,
<a name="l00731"></a>00731         <span class="keyword">const</span> ne10_int32_t nfft)
<a name="l00732"></a>00732 {
<a name="l00733"></a>00733     PRINT_HIT;
<a name="l00734"></a>00734 
<a name="l00735"></a>00735     CPLX in[8];
<a name="l00736"></a>00736     CPLX out[8];
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     <span class="keyword">const</span> ne10_int32_t in_step = nfft / 8;
<a name="l00739"></a>00739     ne10_int32_t f_count;
<a name="l00740"></a>00740     ne10_int32_t m_count;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     <span class="keyword">const</span> REAL one_by_fft_neon = NE10_REAL_DUP_NEON_F32 (0.25 / nfft);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744     <span class="keywordflow">for</span> (f_count = fstride; f_count &gt; 0; f_count--)
<a name="l00745"></a>00745     {
<a name="l00746"></a>00746         <span class="keywordflow">for</span> (m_count = out_step; m_count &gt; 0; m_count--)
<a name="l00747"></a>00747         {
<a name="l00748"></a>00748             in[0] = NE10_CPLX_LOAD (Fin + 0 * in_step);
<a name="l00749"></a>00749             in[1] = NE10_CPLX_LOAD (Fin + 1 * in_step);
<a name="l00750"></a>00750             in[2] = NE10_CPLX_LOAD (Fin + 2 * in_step);
<a name="l00751"></a>00751             in[3] = NE10_CPLX_LOAD (Fin + 3 * in_step);
<a name="l00752"></a>00752             in[4] = NE10_CPLX_LOAD (Fin + 4 * in_step);
<a name="l00753"></a>00753             in[5] = NE10_CPLX_LOAD (Fin + 5 * in_step);
<a name="l00754"></a>00754             in[6] = NE10_CPLX_LOAD (Fin + 6 * in_step);
<a name="l00755"></a>00755             in[7] = NE10_CPLX_LOAD (Fin + 7 * in_step);
<a name="l00756"></a>00756 
<a name="l00757"></a>00757             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00758"></a>00758             {
<a name="l00759"></a>00759                 NE10_FFT8_CONJ (in);
<a name="l00760"></a>00760             }
<a name="l00761"></a>00761 
<a name="l00762"></a>00762             NE10_FFT8_FUC_NEON_F32 (out, in);
<a name="l00763"></a>00763 
<a name="l00764"></a>00764             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00765"></a>00765             {
<a name="l00766"></a>00766                 NE10_FFT8_CONJ (out);
<a name="l00767"></a>00767                 NE10_FFT8_SCALING (out, one_by_fft_neon);
<a name="l00768"></a>00768             }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770             NE10_CPLX_STORE (Fout + 0 * out_step, out[0]);
<a name="l00771"></a>00771             NE10_CPLX_STORE (Fout + 1 * out_step, out[1]);
<a name="l00772"></a>00772             NE10_CPLX_STORE (Fout + 2 * out_step, out[2]);
<a name="l00773"></a>00773             NE10_CPLX_STORE (Fout + 3 * out_step, out[3]);
<a name="l00774"></a>00774             NE10_CPLX_STORE (Fout + 4 * out_step, out[4]);
<a name="l00775"></a>00775             NE10_CPLX_STORE (Fout + 5 * out_step, out[5]);
<a name="l00776"></a>00776             NE10_CPLX_STORE (Fout + 6 * out_step, out[6]);
<a name="l00777"></a>00777             NE10_CPLX_STORE (Fout + 7 * out_step, out[7]);
<a name="l00778"></a>00778 
<a name="l00779"></a>00779             Fin++;
<a name="l00780"></a>00780             Fout += 8;
<a name="l00781"></a>00781         }
<a name="l00782"></a>00782     }
<a name="l00783"></a>00783 }
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 <span class="keyword">template</span>&lt;ne10_<span class="keywordtype">int</span>32_t is_inverse&gt;
<a name="l00786"></a>00786 <span class="keyword">static</span> <span class="keywordtype">void</span> ne10_mixed_radix_generic_butterfly_float32_neon_impl (CPLX *Fout,
<a name="l00787"></a>00787         <span class="keyword">const</span> CPLX *Fin,
<a name="l00788"></a>00788         <span class="keyword">const</span> ne10_int32_t *factors,
<a name="l00789"></a>00789         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l00790"></a>00790         CPLX *buffer)
<a name="l00791"></a>00791 {
<a name="l00792"></a>00792     PRINT_HIT;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794     ne10_int32_t fstride, mstride, radix;
<a name="l00795"></a>00795     ne10_int32_t stage_count;
<a name="l00796"></a>00796     ne10_int32_t nfft;
<a name="l00797"></a>00797 
<a name="l00798"></a>00798     <span class="comment">// init fstride, mstride, radix, nfft</span>
<a name="l00799"></a>00799     stage_count = factors[0];
<a name="l00800"></a>00800     fstride = factors[1];
<a name="l00801"></a>00801     mstride = 1;
<a name="l00802"></a>00802     radix = factors[ stage_count &lt;&lt; 1 ]; <span class="comment">// radix of first stage</span>
<a name="l00803"></a>00803     nfft = fstride * radix;
<a name="l00804"></a>00804 
<a name="l00805"></a>00805     PRINT_HIT;
<a name="l00806"></a>00806 
<a name="l00807"></a>00807     <span class="comment">// swap to make sure output to Fout</span>
<a name="l00808"></a>00808     <span class="keywordflow">if</span> (stage_count % 2 == 0)
<a name="l00809"></a>00809     {
<a name="l00810"></a>00810         ne10_swap_ptr (buffer, Fout);
<a name="l00811"></a>00811     }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813     <span class="comment">// first stage</span>
<a name="l00814"></a>00814     <span class="keywordflow">switch</span> (radix)
<a name="l00815"></a>00815     {
<a name="l00816"></a>00816     <span class="keywordflow">case</span> 2:
<a name="l00817"></a>00817         PRINT_HIT;
<a name="l00818"></a>00818         ne10_radix_2_butterfly_float32_neon&lt;1, is_inverse&gt; (Fout, Fin, NULL,
<a name="l00819"></a>00819                 fstride, 1, nfft);
<a name="l00820"></a>00820         <span class="keywordflow">break</span>;
<a name="l00821"></a>00821     <span class="keywordflow">case</span> 4:
<a name="l00822"></a>00822         PRINT_HIT;
<a name="l00823"></a>00823         ne10_radix_4_butterfly_float32_neon&lt;1, is_inverse&gt; (Fout, Fin, NULL,
<a name="l00824"></a>00824                 fstride, 1, nfft);
<a name="l00825"></a>00825         <span class="keywordflow">break</span>;
<a name="l00826"></a>00826     <span class="keywordflow">case</span> 3:
<a name="l00827"></a>00827         PRINT_HIT;
<a name="l00828"></a>00828         ne10_radix_3_butterfly_float32_neon&lt;1, is_inverse&gt; (Fout, Fin, NULL,
<a name="l00829"></a>00829                 fstride, 1, nfft);
<a name="l00830"></a>00830         <span class="keywordflow">break</span>;
<a name="l00831"></a>00831     <span class="keywordflow">case</span> 5:
<a name="l00832"></a>00832         PRINT_HIT;
<a name="l00833"></a>00833         ne10_radix_5_butterfly_float32_neon&lt;1, is_inverse&gt; (Fout, Fin, NULL,
<a name="l00834"></a>00834                 fstride, 1, nfft);
<a name="l00835"></a>00835         <span class="keywordflow">break</span>;
<a name="l00836"></a>00836     <span class="keywordflow">case</span> 8:
<a name="l00837"></a>00837         PRINT_HIT;
<a name="l00838"></a>00838         ne10_radix_8_butterfly_float32_neon&lt;1, is_inverse&gt; (Fout, Fin, NULL,
<a name="l00839"></a>00839                 fstride, 1, nfft);
<a name="l00840"></a>00840         <span class="keywordflow">break</span>;
<a name="l00841"></a>00841     }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843     stage_count--;
<a name="l00844"></a>00844     <span class="keywordflow">if</span> (! stage_count) <span class="comment">// finish</span>
<a name="l00845"></a>00845     {
<a name="l00846"></a>00846         <span class="keywordflow">return</span>;
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849     mstride *= radix;
<a name="l00850"></a>00850 
<a name="l00851"></a>00851     <span class="comment">// update radix</span>
<a name="l00852"></a>00852     <span class="keywordflow">if</span> (radix % 2)
<a name="l00853"></a>00853     {
<a name="l00854"></a>00854         twiddles += radix;
<a name="l00855"></a>00855     }
<a name="l00856"></a>00856     radix = factors[ stage_count &lt;&lt; 1 ];
<a name="l00857"></a>00857 
<a name="l00858"></a>00858     <span class="comment">// other stages</span>
<a name="l00859"></a>00859     <span class="keywordflow">while</span> (stage_count &gt; 0)
<a name="l00860"></a>00860     {
<a name="l00861"></a>00861 
<a name="l00862"></a>00862         <span class="comment">// radix of first stage, should be one of {2,3,5,4}</span>
<a name="l00863"></a>00863         assert ((radix &gt; 1) &amp;&amp; (radix &lt; 6));
<a name="l00864"></a>00864 
<a name="l00865"></a>00865         ne10_swap_ptr (buffer, Fout);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867         fstride /= radix;
<a name="l00868"></a>00868         <span class="keywordflow">switch</span> (radix)
<a name="l00869"></a>00869         {
<a name="l00870"></a>00870         <span class="keywordflow">case</span> 2:
<a name="l00871"></a>00871             ne10_radix_2_butterfly_float32_neon&lt;0, is_inverse&gt; (Fout, buffer,
<a name="l00872"></a>00872                     twiddles, fstride, mstride, nfft);
<a name="l00873"></a>00873             <span class="keywordflow">break</span>;
<a name="l00874"></a>00874         <span class="keywordflow">case</span> 3:
<a name="l00875"></a>00875             ne10_radix_3_butterfly_float32_neon&lt;0, is_inverse&gt; (Fout, buffer,
<a name="l00876"></a>00876                     twiddles, fstride, mstride, nfft);
<a name="l00877"></a>00877             <span class="keywordflow">break</span>;
<a name="l00878"></a>00878         <span class="keywordflow">case</span> 4:
<a name="l00879"></a>00879             ne10_radix_4_butterfly_float32_neon&lt;0, is_inverse&gt; (Fout, buffer,
<a name="l00880"></a>00880                     twiddles, fstride, mstride, nfft);
<a name="l00881"></a>00881             <span class="keywordflow">break</span>;
<a name="l00882"></a>00882         <span class="keywordflow">case</span> 5:
<a name="l00883"></a>00883             ne10_radix_5_butterfly_float32_neon&lt;0, is_inverse&gt; (Fout, buffer,
<a name="l00884"></a>00884                     twiddles, fstride, mstride, nfft);
<a name="l00885"></a>00885             <span class="keywordflow">break</span>;
<a name="l00886"></a>00886         } <span class="comment">// switch (radix)</span>
<a name="l00887"></a>00887 
<a name="l00888"></a>00888         twiddles += mstride * (radix - 1);
<a name="l00889"></a>00889         mstride *= radix;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891         stage_count--;
<a name="l00892"></a>00892         radix = factors[ stage_count &lt;&lt; 1 ];
<a name="l00893"></a>00893     } <span class="comment">// while (stage_count)</span>
<a name="l00894"></a>00894 }
<a name="l00895"></a>00895 
<a name="l00896"></a>00896 <span class="keyword">template</span>&lt;ne10_<span class="keywordtype">int</span>32_t is_inverse&gt;
<a name="l00897"></a>00897 <span class="keyword">static</span> <span class="keywordtype">void</span> ne10_c2c_1d_last_stage_neon (CPLX *Fout,
<a name="l00898"></a>00898         <span class="keyword">const</span> CPLX *Fin,
<a name="l00899"></a>00899         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l00900"></a>00900         <span class="keyword">const</span> ne10_int32_t fstride,
<a name="l00901"></a>00901         <span class="keyword">const</span> ne10_int32_t out_step,
<a name="l00902"></a>00902         <span class="keyword">const</span> ne10_int32_t nfft)
<a name="l00903"></a>00903 {
<a name="l00904"></a>00904 <span class="preprocessor">#ifdef NE10_VERBOSE</span>
<a name="l00905"></a>00905 <span class="preprocessor"></span>    <span class="comment">// Clear Fout</span>
<a name="l00906"></a>00906     <span class="keywordtype">int</span> i;
<a name="l00907"></a>00907     <span class="keywordflow">for</span> (i = 0; i &lt; nfft; i++)
<a name="l00908"></a>00908     {
<a name="l00909"></a>00909         ((<a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *) Fout)[i].r = 0.0;
<a name="l00910"></a>00910         ((<a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *) Fout)[i].i = 0.0;
<a name="l00911"></a>00911     }
<a name="l00912"></a>00912 <span class="preprocessor">#endif</span>
<a name="l00913"></a>00913 <span class="preprocessor"></span>
<a name="l00914"></a>00914     ne10_int32_t f_count;
<a name="l00915"></a>00915     ne10_int32_t m_count;
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     <span class="keywordflow">for</span> (f_count = fstride; f_count &gt; 0; f_count--)
<a name="l00918"></a>00918     {
<a name="l00919"></a>00919         CPLX scratch_in[4];
<a name="l00920"></a>00920         CPLX scratch_out[4];
<a name="l00921"></a>00921 
<a name="l00922"></a>00922         <span class="keywordflow">for</span> (m_count = out_step / NE10_FFT_PARA_LEVEL; m_count &gt; 0; m_count--)
<a name="l00923"></a>00923         {
<a name="l00924"></a>00924             scratch_in[0] = NE10_CPLX_LOAD (Fin + 0);
<a name="l00925"></a>00925             scratch_in[1] = NE10_CPLX_LOAD (Fin + 1);
<a name="l00926"></a>00926             scratch_in[2] = NE10_CPLX_LOAD (Fin + 2);
<a name="l00927"></a>00927             scratch_in[3] = NE10_CPLX_LOAD (Fin + 3);
<a name="l00928"></a>00928 
<a name="l00929"></a>00929             <span class="comment">// Transpose</span>
<a name="l00930"></a>00930             {
<a name="l00931"></a>00931                 CPLX scratch0, scratch_in0;
<a name="l00932"></a>00932                 CPLX scratch1, scratch_in1;
<a name="l00933"></a>00933                 CPLX scratch2, scratch_in2;
<a name="l00934"></a>00934                 CPLX scratch3, scratch_in3;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936                 scratch_in0 = scratch_in[0];
<a name="l00937"></a>00937                 scratch_in1 = scratch_in[1];
<a name="l00938"></a>00938                 scratch_in2 = scratch_in[2];
<a name="l00939"></a>00939                 scratch_in3 = scratch_in[3];
<a name="l00940"></a>00940 
<a name="l00941"></a>00941                 NE10_RADIX4X4C_TRANSPOSE_NEON (scratch, scratch_in);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943                 scratch_in[0] = scratch0;
<a name="l00944"></a>00944                 scratch_in[1] = scratch1;
<a name="l00945"></a>00945                 scratch_in[2] = scratch2;
<a name="l00946"></a>00946                 scratch_in[3] = scratch3;
<a name="l00947"></a>00947             }
<a name="l00948"></a>00948 
<a name="l00949"></a>00949             <span class="keywordflow">if</span> (is_inverse)
<a name="l00950"></a>00950             {
<a name="l00951"></a>00951                 NE10_FFT4_CONJ (scratch_in);
<a name="l00952"></a>00952             }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954             <span class="comment">// Not first stage</span>
<a name="l00955"></a>00955             {
<a name="l00956"></a>00956                 CPLX scratch_tw[3];
<a name="l00957"></a>00957 
<a name="l00958"></a>00958                 scratch_tw[0] = NE10_CPLX_LOAD (twiddles + 0 * out_step);
<a name="l00959"></a>00959                 scratch_tw[1] = NE10_CPLX_LOAD (twiddles + 1 * out_step);
<a name="l00960"></a>00960                 scratch_tw[2] = NE10_CPLX_LOAD (twiddles + 2 * out_step);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962                 NE10_FFT4_MUL_TW_NEON (scratch_in, scratch_in, scratch_tw);
<a name="l00963"></a>00963             }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965             NE10_FFT4_FUC_NEON_F32 (scratch_out, scratch_in);
<a name="l00966"></a>00966 
<a name="l00967"></a>00967             <span class="keywordflow">if</span> (is_inverse == 1)
<a name="l00968"></a>00968             {
<a name="l00969"></a>00969                 NE10_FFT4_CONJ (scratch_out);
<a name="l00970"></a>00970             }
<a name="l00971"></a>00971 
<a name="l00972"></a>00972             <span class="comment">// Store.</span>
<a name="l00973"></a>00973             {
<a name="l00974"></a>00974                 <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *Fout_cpx;
<a name="l00975"></a>00975                 Fout_cpx = (<a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *) Fout;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977                 NE10_CPLX_STORE (Fout_cpx + 0 * out_step, scratch_out[0]);
<a name="l00978"></a>00978                 NE10_CPLX_STORE (Fout_cpx + 1 * out_step, scratch_out[1]);
<a name="l00979"></a>00979                 NE10_CPLX_STORE (Fout_cpx + 2 * out_step, scratch_out[2]);
<a name="l00980"></a>00980                 NE10_CPLX_STORE (Fout_cpx + 3 * out_step, scratch_out[3]);
<a name="l00981"></a>00981             }
<a name="l00982"></a>00982 
<a name="l00983"></a>00983             Fin += 4;
<a name="l00984"></a>00984             Fout += 1;
<a name="l00985"></a>00985             twiddles += 4;
<a name="l00986"></a>00986         }
<a name="l00987"></a>00987     }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989     ne10_int32_t left_over = out_step % 4;
<a name="l00990"></a>00990     <span class="keywordflow">if</span> (left_over == 0)
<a name="l00991"></a>00991     {
<a name="l00992"></a>00992         <span class="keywordflow">return</span>;
<a name="l00993"></a>00993     }
<a name="l00994"></a>00994 
<a name="l00995"></a>00995     <span class="comment">// Left over.</span>
<a name="l00996"></a>00996     <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *Fin_s  = (<a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *) Fin;
<a name="l00997"></a>00997     <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *Fout_s = (<a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *) Fout;
<a name="l00998"></a>00998     <span class="keywordflow">for</span> (m_count = out_step % 4; m_count &gt; 0; m_count--)
<a name="l00999"></a>00999     {
<a name="l01000"></a>01000         <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> scratch_in[4];
<a name="l01001"></a>01001         <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> scratch_tw[4];
<a name="l01002"></a>01002 
<a name="l01003"></a>01003         scratch_in[0] = Fin_s[0];
<a name="l01004"></a>01004         scratch_in[1] = Fin_s[1];
<a name="l01005"></a>01005         scratch_in[2] = Fin_s[2];
<a name="l01006"></a>01006         scratch_in[3] = Fin_s[3];
<a name="l01007"></a>01007 
<a name="l01008"></a>01008         <span class="keywordflow">if</span> (is_inverse)
<a name="l01009"></a>01009         {
<a name="l01010"></a>01010             scratch_in[0].i = -scratch_in[0].i;
<a name="l01011"></a>01011             scratch_in[1].i = -scratch_in[1].i;
<a name="l01012"></a>01012             scratch_in[2].i = -scratch_in[2].i;
<a name="l01013"></a>01013             scratch_in[3].i = -scratch_in[3].i;
<a name="l01014"></a>01014         }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016         scratch_tw[0] = twiddles[0 * out_step];
<a name="l01017"></a>01017         scratch_tw[1] = twiddles[1 * out_step];
<a name="l01018"></a>01018         scratch_tw[2] = twiddles[2 * out_step];
<a name="l01019"></a>01019 
<a name="l01020"></a>01020         FFT4_MUL_TW (scratch_in, scratch_in, scratch_tw);
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         FFT4_FCU_INPLACE (scratch_in);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <span class="keywordflow">if</span> (is_inverse)
<a name="l01025"></a>01025         {
<a name="l01026"></a>01026             scratch_in[0].i = -scratch_in[0].i;
<a name="l01027"></a>01027             scratch_in[1].i = -scratch_in[1].i;
<a name="l01028"></a>01028             scratch_in[2].i = -scratch_in[2].i;
<a name="l01029"></a>01029             scratch_in[3].i = -scratch_in[3].i;
<a name="l01030"></a>01030         }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032         Fout_s[0 * out_step] = scratch_in[0];
<a name="l01033"></a>01033         Fout_s[1 * out_step] = scratch_in[1];
<a name="l01034"></a>01034         Fout_s[2 * out_step] = scratch_in[2];
<a name="l01035"></a>01035         Fout_s[3 * out_step] = scratch_in[3];
<a name="l01036"></a>01036 
<a name="l01037"></a>01037         Fin_s += 4;
<a name="l01038"></a>01038         Fout_s += 1;
<a name="l01039"></a>01039         twiddles += 1;
<a name="l01040"></a>01040     }
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="keywordtype">void</span> ne10_mixed_radix_generic_butterfly_float32_neon (
<a name="l01044"></a>01044         <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *Fout,
<a name="l01045"></a>01045         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *Fin,
<a name="l01046"></a>01046         <span class="keyword">const</span> ne10_int32_t *factors,
<a name="l01047"></a>01047         <span class="keyword">const</span> <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l01048"></a>01048         <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *buffer)
<a name="l01049"></a>01049 {
<a name="l01050"></a>01050     PRINT_HIT;
<a name="l01051"></a>01051 
<a name="l01052"></a>01052     ne10_int32_t stage_count = factors[0];
<a name="l01053"></a>01053     ne10_int32_t fstride = factors[1];
<a name="l01054"></a>01054     ne10_int32_t radix = factors[stage_count &lt;&lt; 1]; <span class="comment">// radix of first stage</span>
<a name="l01055"></a>01055 
<a name="l01056"></a>01056     <span class="comment">// nfft below is not the actual length of FFT, it is 1/4 of the actual one</span>
<a name="l01057"></a>01057     <span class="comment">// instead.</span>
<a name="l01058"></a>01058     ne10_int32_t nfft = fstride * radix;
<a name="l01059"></a>01059 
<a name="l01060"></a>01060     ne10_mixed_radix_generic_butterfly_float32_neon_impl&lt;0&gt; ((CPLX *) buffer,
<a name="l01061"></a>01061             (<span class="keyword">const</span> CPLX *) Fin, <span class="comment">// From Fin to buffer</span>
<a name="l01062"></a>01062             factors,
<a name="l01063"></a>01063             twiddles,
<a name="l01064"></a>01064             (CPLX *) Fout); <span class="comment">// Fout is &quot;buffer&quot; for these stages.</span>
<a name="l01065"></a>01065 
<a name="l01066"></a>01066     ne10_c2c_1d_last_stage_neon&lt;0&gt; ((CPLX *) Fout,
<a name="l01067"></a>01067             (const CPLX *) buffer, <span class="comment">// From buffer to Fout</span>
<a name="l01068"></a>01068             twiddles + nfft,
<a name="l01069"></a>01069             1, <span class="comment">// out_step == fstride == 1</span>
<a name="l01070"></a>01070             nfft, <span class="comment">// in_step == mstride == nfft</span>
<a name="l01071"></a>01071             nfft * 4); <span class="comment">// Actual length of FFT</span>
<a name="l01072"></a>01072 
<a name="l01073"></a>01073     PRINT_HIT;
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="keywordtype">void</span> ne10_mixed_radix_generic_butterfly_inverse_float32_neon (
<a name="l01077"></a>01077         <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *Fout,
<a name="l01078"></a>01078         const <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *Fin,
<a name="l01079"></a>01079         const ne10_int32_t *factors,
<a name="l01080"></a>01080         const <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *twiddles,
<a name="l01081"></a>01081         <a class="code" href="structne10__fft__cpx__float32__t.html">ne10_fft_cpx_float32_t</a> *buffer)
<a name="l01082"></a>01082 {
<a name="l01083"></a>01083     PRINT_HIT;
<a name="l01084"></a>01084 
<a name="l01085"></a>01085     ne10_int32_t stage_count = factors[0];
<a name="l01086"></a>01086     ne10_int32_t fstride = factors[1];
<a name="l01087"></a>01087     ne10_int32_t radix = factors[stage_count &lt;&lt; 1]; <span class="comment">// radix of first stage</span>
<a name="l01088"></a>01088 
<a name="l01089"></a>01089     <span class="comment">// nfft below is not the actual length of FFT, it is 1/4 of the actual one</span>
<a name="l01090"></a>01090     <span class="comment">// instead.</span>
<a name="l01091"></a>01091     ne10_int32_t nfft = fstride * radix;
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     ne10_mixed_radix_generic_butterfly_float32_neon_impl&lt;1&gt; ((CPLX *) buffer,
<a name="l01094"></a>01094             (<span class="keyword">const</span> CPLX *) Fin, <span class="comment">// From Fin to buffer</span>
<a name="l01095"></a>01095             factors,
<a name="l01096"></a>01096             twiddles,
<a name="l01097"></a>01097             (CPLX *) Fout); <span class="comment">// Fout is &quot;buffer&quot; for these stages.</span>
<a name="l01098"></a>01098 
<a name="l01099"></a>01099     ne10_c2c_1d_last_stage_neon&lt;1&gt; ((CPLX *) Fout,
<a name="l01100"></a>01100             (const CPLX *) buffer, <span class="comment">// From buffer to Fout</span>
<a name="l01101"></a>01101             twiddles + nfft,
<a name="l01102"></a>01102             1, <span class="comment">// out_step == fstride == 1</span>
<a name="l01103"></a>01103             nfft, <span class="comment">// in_step == mstride == nfft</span>
<a name="l01104"></a>01104             nfft * 4); <span class="comment">// Actual length of FFT</span>
<a name="l01105"></a>01105 
<a name="l01106"></a>01106     PRINT_HIT;
<a name="l01107"></a>01107 }
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Jan 21 2015 18:47:14 for Project Ne10 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
